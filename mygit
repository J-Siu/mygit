#!bash

# {$@} Log message
LOG() {
	#	[ -n "${fileLOG}" ] && {echo "$@" >>${fileLOG}}
	echo -e "log:$@"
}

# ${@s} CMD
RUN_CMD() {
	local _CMD="${@}"

	[ ${_DEBUG} ] && LOG "CMD:${_CMD}"

	${_CMD}
	local _RTN=$?

	[ ${_RTN} -ne 0 ] && LOG "CMD:${_CMD} error:${_RTN}"

	return ${_RTN}
}

# ${1} _API
# ${2} _TOK
# ${3} _X
# ${4} _D
# ${5} _JQ
API_CURL() {
	local _me="API_CURL"

	local _API=${1}
	local _TOK=${2}
	local _X=${3}
	local _D=${4}
	local _JQ=${5}

	local _d=''
	[[ ! ${_D} = ' ' ]] && _d="-d"

	local _x=''
	[[ ! ${_X} = ' ' ]] && _x="-X"

	if [[ ${_DEBUG} ]]; then
		LOG ${_me}:_API:${_API}
		LOG ${_me}:_D:${_D}
		LOG ${_me}:_JQ:${_JQ}
		LOG ${_me}:_TOK:${_TOK}
		LOG ${_me}:_X:${_X}
		LOG ${_me}:_d:${_d}
		LOG ${_me}:_x:${_x}
	fi

	curl -s \
		${_x} ${_X} \
		-H "Accept: application/vnd.github.mercy-preview+json" \
		-H "Accept: application/vnd.github.v3+json" \
		-H "Content-Type: application/json" \
		-H "Authorization: token ${_TOK}" \
		${_d} "${_D}" \
		${_API} | jq ${_JQ}
}

# Add all remotes in group to global var REMOTE
ADD_GROUP() {
	local _me="ADD_GROUP"
	[[ ${_DEBUG} ]] && LOG ${_me}:${@}

	local _group=${@}
	for _g in ${_group}; do
		for _r in ${MY_GIT_REMOTE}; do
			[[ "${MY_GIT[${_r}.grp]}" = "${_g}" ]] && ! $(_in_group ${_r} "${REMOTE}") && REMOTE+=" ${_r}"
		done
	done
}

# Add remote to global var REMOTE
ADD_REMOTE() {
	local _me="ADD_REMOTE"
	[[ ${_DEBUG} ]] && LOG ${_me}:${@}

	local _remote=${@}
	for _r in ${_remote}; do
		$(_in_group ${_r} "${MY_GIT_REMOTE}") && ! $(_in_group ${_r} "${REMOTE}") && REMOTE+=" ${_r}"
	done
}

# Join git remote with REMOTE
MERGE_REMOTE() {
	local _remote=''

	if [[ ${REMOTE} ]]; then
		for _r in $(git remote); do
			$(_in_group ${_r} "${REMOTE}") && _remote+=" ${_r}"
		done
	else
		_remote=$(git remote)
	fi

	echo ${_remote}
}

# Check word in group(string)
# ${1} word
# ${2} group
_in_group() {
	local _word=${1}
	local _group=${2}
	for _g in ${_group}; do
		[ ${_g} == ${_word} ] && return 0
	done
	return 1
}

# Extract all groups from MY_GIT
_mygit_group() {
	local _group=''
	local _remote=$(_mygit_remote)
	for _r in ${_remote}; do
		local _g=${MY_GIT[${_r}.grp]}
		! $(_in_group ${_g} "${_group}") && _group+=" ${_g}"
	done
	echo ${_group}
}

# Extract all remotes from MY_GIT
_mygit_remote() {
	local _remote=''
	local _key

	if [ ${BASH_VERSION} ]; then
		_key=${!MY_GIT[@]}
	fi

	for _i in ${_key}; do
		local _r=${_i%.*}
		! $(_in_group ${_r} "${_remote}") && _remote+=" ${_r}"
	done
	echo ${_remote}
}

# ${1} site
_mygit_remote_add() {
	local _remote=${1}

	local _SSH=${MY_GIT[${_remote}.ssh]}
	local _USR=${MY_GIT[${_remote}.usr]}
	local _GIT="${_SSH}:/${_USR}/${REPO}.git"
	RUN_CMD "git remote add ${_remote} ${_GIT}"
}

_mygit_remote_clear() {
	local _remote=$(git remote 2>/dev/null)
	local _result=$?
	if [[ ${_result} == 0 ]]; then
		for _r in ${_remote}; do
			RUN_CMD "git remote remove ${_r}"
		done
	fi
}

option() {
	local _me="option"
	local _state=0

	while [[ ${ARGV[${ARGP}]} ]]; do
		[[ ${_DEBUG} ]] && LOG ${_me}:ARGP:${ARGP}
		local _ARG=${ARGV[${ARGP}]}
		((ARGP++))
		case ${_state} in
		0)
			case ${_ARG} in
			"-g" | "--group")
				_state=1
				;;
			"-r" | "--remote")
				_state=2
				;;
			"fetch")
				RUN_CMD "c_fetch"
				;;
			"group")
				echo ${MY_GIT_GROUP}
				;;
			"init")
				RUN_CMD "c_init"
				;;
			"push")
				RUN_CMD "o_push"
				;;
			"repo" | "repository")
				RUN_CMD "o_repo"
				;;
			"remote")
				for _r in ${MY_GIT_REMOTE}; do
					echo "${_r} (${MY_GIT[${_r}.grp]})"
				done
				;;
			*)
				echo usage
				return 1
				;;
			esac
			;;
		1)
			# group
			! _in_group ${_ARG} ${MY_GIT_GROUP} && echo "Group ${_ARG} not found." && exit 1
			_state=0
			ADD_GROUP ${_ARG}
			[[ ${_DEBUG} ]] && LOG "option:-g:${REMOTE}"
			;;
		2)
			# remote
			! _in_group ${_ARG} ${MY_GIT_REMOTE} && echo "Remote ${_ARG} not found." && exit 1
			_state=0
			ADD_REMOTE ${_ARG}
			[[ ${_DEBUG} ]] && LOG "option:-r:${REMOTE}"
			;;
		esac
	done

}

c_fetch() {
	local _me="c_fetch"
	[[ ${_DEBUG} ]] && LOG ${_me}:ARGP:${ARGP}

	for _r in $(MERGE_REMOTE); do
		echo remote:${_r}
		RUN_CMD "git fetch $_r"
		echo ---
	done
}

c_init() {

	local _me="o_init"
	[[ ${_DEBUG} ]] && LOG ${_me}:ARGP:${ARGP}
	[[ ${_DEBUG} ]] && LOG ${_me}:REMOTE:${REMOTE}

	if [[ ${ARGV[${ARGP}]} ]]; then
		REPO=${ARGV[${ARGP}]}
		# Create .mygit
		echo ${REPO} >.mygit
		((ARGP++))
	else
		REPO=${PWD##*/}
		[ -f ".mygit" ] && rm .mygit
	fi

	git init

	# Clear remote
	_mygit_remote_clear

	[[ ! ${REMOTE} ]] && REMOTE=${MY_GIT_REMOTE}

	for _r in ${REMOTE}; do
		echo remote:${_r}
		_mygit_remote_add ${_r}
	done
}

o_push() {
	local _me="o_push"
	[[ ${_DEBUG} ]] && LOG ${_me}:ARGP:${ARGP}

	local _OPT=''
	local _BRANCH=''

	local _ARG=${ARGV[${ARGP}]}
	case ${_ARG} in
	"") ;;
	"--all")
		_OPT='' # unset upstream
		_BRANCH="--all"
		;;
	"--master")
		_OPT="-u" # set upstream
		_BRANCH="master"
		;;
	*)
		echo 'usage: mygit <-g <group>|-r <remote>> push <--master|--all>'
		;;
	esac

	for _r in $(MERGE_REMOTE); do
		echo remote:${_r}
		RUN_CMD "git push ${_OPT} ${_r} ${_BRANCH}"
		RUN_CMD "git push ${_r} --tags"
		echo ---
	done

}

o_repo() {
	local _me="o_repo"
	[[ ${_DEBUG} ]] && LOG ${_me}:ARGP:${ARGP}

	local _state=0
	local _action
	local _archive
	local _desc=''
	local _topic=''
	local _private=''
	local _remote=''
	local _X=' ' # curl -X
	local _D=' ' # curl -d
	local _JQ="."

	while [[ ${ARGV[${ARGP}]} ]]; do
		local _ARG=${ARGV[${ARGP}]}
		((ARGP++))
		case ${_state} in
		0)
			case ${_ARG} in
			"del" | "delete")
				_action="del"
				;;
			"desc" | "description")
				_action="desc"
				_state=1
				;;
			"ls" | "list")
				_action="ls"
				;;
			"new")
				_action="new"
				;;
			"topic" | "topics")
				_action="topic"
				_state=2
				;;
			"vis" | "visibility")
				_action="vis"
				;;
			"--pri" | "--private")
				_private=true
				;;
			"--pub" | "--public")
				_private=false
				;;
			"--archive" | "--archived")
				_archive=true
				;;
			*)
				echo usage: ${_me}
				return 1
				;;
			esac
			;;
		1)
			[[ ${_DEBUG} ]] && LOG o_repo:1:_ARG:${_ARG}
			_state=0
			_desc="${_ARG}"
			;;
		2)
			[[ ${_DEBUG} ]] && LOG o_repo:2:_ARG:${_ARG}
			_state=0
			for _t in ${_ARG}; do
				if [ ${_topic} ]; then
					_topic+=",\"${_t}\""
				else
					_topic="\"${_t}\""
				fi
			done
			;;

		esac
	done

	if [[ "${_action}" = "ls" ]]; then
		if [[ ${REMOTE} ]]; then
			# list only rely on MY_GIT config
			_remote=${REMOTE}
		else
			# if no group/remote specified, then list all
			_remote=${MY_GIT_REMOTE}
		fi
	else
		_remote=$(MERGE_REMOTE)
	fi

	for _r in ${_remote}; do
		local _DEL=${MY_GIT[${_r}.del]}
		local _PRI=${MY_GIT[${_r}.pri]}
		local _TOK=${MY_GIT[${_r}.tok]}
		local _URI=${MY_GIT[${_r}.uri]}
		local _USR=${MY_GIT[${_r}.usr]}
		local _VEN=${MY_GIT[${_r}.ven]}
		local _API

		if [[ "${_action}" = "del" ]]; then
			_API=${_URI}/repos/${_USR}/${REPO}
			_X="DELETE"
			[[ ${_DEL} ]] && _TOK=${_DEL}
		elif [[ "${_action}" = "desc" ]]; then
			_API=${_URI}/repos/${_USR}/${REPO}
			_JQ="-r .description"
			if [[ ${_desc} ]]; then
				_D="{\"description\":\"${_desc}\"}"
				_X="PATCH"
			fi
		elif [[ "${_action}" = "ls" ]]; then
			_API=${_URI}/user/repos
			if [ "${_VEN}" = "github" ]; then
				_API="${_API}?per_page=100"
			else # gogs/gitea
				_API="${_API}?limit=100"
			fi

			if [[ ${_archive} ]]; then
				_JQ='-r .[]|{name}|.name'
			else
				_JQ='-r .[]|select(.archived==false)|{name}|.name'
			fi
		elif [[ "${_action}" = "new" ]]; then
			if [[ ! ${_private} ]]; then
				if [[ ${_PRI} ]]; then
					_private=${_PRI}
				else
					_private=true
				fi
			fi
			[[ ${_DEBUG} ]] && [[ ${_X} ]] && LOG ${_me}:_private:${_private}
			_API=${_URI}/user/repos
			_D="{\"name\":\"${REPO}\",\"private\":${_private}}"
		elif [[ "${_action}" = "topic" ]]; then
			_API=${_URI}/repos/${_USR}/${REPO}/topics
			if [[ ${_topic} ]]; then
				_X="PUT"
				case ${_VEN} in
				"github")
					_D="{\"names\":[${_topic}]}"
					;;
				"gogs" | "gitea")
					_D="{\"topics\":[${_topic}]}"
					;;
				esac
			fi
		elif [[ "${_action}" = "vis" ]]; then
			[[ ${_DEBUG} ]] && [[ ${_X} ]] && LOG ${_me}:_private:${_private}
			_API=${_URI}/repos/${_USR}/${REPO}
			_JQ='({private})|to_entries[]|"\(.key)=\(.value)"'
			if [[ ${_private} ]]; then
				_D="{\"private\":${_private}}"
				_X="PATCH"
			fi
		else # Get repo remote info
			_API=${_URI}/repos/${_USR}/${REPO}
			_JQ='.'
		fi

		echo ${_r}:${_API}
		[[ ${_DEBUG} ]] && [[ ${_X} ]] && LOG ${_me}:_X:${_X}
		[[ ${_DEBUG} ]] && [[ ${_D} ]] && LOG ${_me}:_D:${_D}
		API_CURL "${_API}" "${_TOK}" "${_X}" "${_D}" "${_JQ}"
		echo ---
	done
}

# ---

# Minimum bash version 4
[[ ${BASH_VERSION} ]] && [[ ${BASH_VERSION} < 4 ]] && echo "${BASH_VERSION} < 4" && exit 1

# CONF
typeset -A MY_GIT
CONF=~/.mygit.conf
if [ -f ${CONF} ]; then
	source ${CONF}
else
	echo "${CONF} not found."
	exit 1
fi
MY_GIT_REMOTE=$(_mygit_remote)
MY_GIT_GROUP=$(_mygit_group)

# ARG
ARGP=1
ARGC=${#@}
declare -a ARGV
_c=1
for _j in "${@}"; do
	ARGV[${_c}]=${_j}
	((_c++))
done

if [ -f ".mygit" ]; then
	REPO=$(cat .mygit)
else
	REPO=${PWD##*/}
fi
REMOTE=''

# DEBUG
if [[ ${_DEBUG} ]]; then
	LOG BASH_VERSION:${BASH_VERSION}
	LOG MY_GIT_REMOTE:${MY_GIT_REMOTE}
	LOG MY_GIT_GROUP:${MY_GIT_GROUP}
	for _i in $(seq 1 ${#ARGV[@]}); do
		LOG ARGV[${_i}]:${ARGV[${_i}]}
	done
	LOG REPO:${REPO}
fi

option
