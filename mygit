#!/usr/bin/env bash

# {$@} Log message
LOG() {
	#	[ -n "${fileLOG}" ] && {echo "$@" >>${fileLOG}}
	echo -e "log:$@"
}

# ${@s} CMD
RUN_CMD() {
	local _CMD="${@}"

	[ ${_DEBUG} ] && LOG "CMD:${_CMD}"

	${_CMD}
	local _RTN=$?

	[ ${_RTN} -ne 0 ] && LOG "CMD:${_CMD} error:${_RTN}"

	return ${_RTN}
}

# ${1} _API
# ${2} _TOK
# ${3} _X
# ${4} _D
# ${5} _JQ
API_CURL() {
	local _me="API_CURL"

	local _API=${1}
	local _TOK=${2}
	local _X=${3}
	local _D=${4}
	local _JQ=${5}

	local _d=''
	[[ ! ${_D} = ' ' ]] && _d="-d"

	local _x=''
	[[ ! ${_X} = ' ' ]] && _x="-X"

	if [[ ${_DEBUG} ]]; then
		LOG "${_me}:_API:${_API}"
		LOG "${_me}:_D:${_D}"
		LOG "${_me}:_JQ:${_JQ}"
		LOG "${_me}:_TOK:${_TOK}"
		LOG "${_me}:_X:${_X}"
		LOG "${_me}:_d:${_d}"
		LOG "${_me}:_x:${_x}"
	fi

	curl -s \
		${_x} ${_X} \
		-H "Accept: application/vnd.github.mercy-preview+json" \
		-H "Accept: application/vnd.github.v3+json" \
		-H "Content-Type: application/json" \
		-H "Authorization: token ${_TOK}" \
		${_d} "${_D}" \
		${_API} | jq ${_JQ}
}

# Add all remotes in group to global var REMOTE
ADD_GROUP() {
	local _me="ADD_GROUP"
	[[ ${_DEBUG} ]] && LOG "${_me}:${@}"

	local _group=${@}
	for _g in ${_group}; do
		for _r in ${MY_GIT_REMOTE}; do
			[[ "${MY_GIT[${_r}.grp]}" = "${_g}" ]] && ! _in_group ${_r} "${REMOTE}" && REMOTE+=" ${_r}"
		done
	done
}

# Add remote to global var REMOTE
ADD_REMOTE() {
	local _me="ADD_REMOTE"
	[[ ${_DEBUG} ]] && LOG "${_me}:${@}"

	local _remote=${@}
	for _r in ${_remote}; do
		_in_group ${_r} "${MY_GIT_REMOTE}" && ! _in_group ${_r} "${REMOTE}" && REMOTE+=" ${_r}"
	done
}

# Join git remote with REMOTE
MERGE_REMOTE() {
	local __remote=''

	if [[ ${REMOTE} ]]; then
		for _x in $(git remote); do
			_in_group ${_x} "${REMOTE}" && __remote+=" ${_x}"
		done
	else
		__remote=$(git remote)
	fi

	echo ${__remote}
}

# Check word in group(string)
# ${1} word
# ${2} group
_in_group() {
	local _me="_in_group"
	local _word=${1}
	local _group=${2}
	for _x in ${_group}; do
		[ ${_x} == ${_word} ] && return 0
	done
	return 1
}

# Extract all groups from MY_GIT
_mygit_group() {
	local _me="_mygit_group"

	[[ ! ${MY_GIT_REMOTE} ]] && _mygit_remote
	local _remote=${MY_GIT_REMOTE}

	[[ ${_DEBUG} ]] && LOG "${_me}:_remote:${_remote}"

	for _r in ${_remote}; do
		local _g=${MY_GIT[${_r}.grp]}
		[[ ${_DEBUG} ]] && LOG "${_me}:_g:${_g}"
		! _in_group ${_g} "${MY_GIT_GROUP}" && MY_GIT_GROUP+=" ${_g}"
		[[ ${_DEBUG} ]] && LOG "${_me}:MY_GIT_GROUP:${MY_GIT_GROUP}"
	done
}

# Extract all remotes from MY_GIT
_mygit_remote() {
	local _key

	if [ ${BASH_VERSION} ]; then
		_key=${!MY_GIT[@]}
	fi

	for _i in ${_key}; do
		local _r=${_i%.*}
		! _in_group ${_r} "${MY_GIT_REMOTE}" && MY_GIT_REMOTE+=" ${_r}"
	done
}

# ${1} site
_mygit_remote_add() {
	local _remote=${1}

	local _SSH=${MY_GIT[${_remote}.ssh]}
	local _USR=${MY_GIT[${_remote}.usr]}
	local _GIT="${_SSH}:/${_USR}/${REPO}.git"
	RUN_CMD "git remote add ${_remote} ${_GIT}"
}

_mygit_remote_clear() {
	local _remote=$(git remote 2>/dev/null)
	local _result=$?
	if [[ ${_result} == 0 ]]; then
		for _r in ${_remote}; do
			RUN_CMD "git remote remove ${_r}"
		done
	fi
}

_mygit_usage() {
	echo 'mygit remote                                                       # Show remotes in config'
	echo 'mygit group                                                        # Show groups in config'
	echo 'mygit [-g <group>] [-r <remote>] fetch                             # Git fetch'
	echo 'mygit [-g <group>] [-r <remote>] init [<repository name>]          # Git init'
	echo 'mygit [-g <group>] [-r <remote>] push [--all|--master]             # Git push'
	echo 'mygit [-g <group>] [-r <remote>] repo                              # API get remote repository information'
	echo 'mygit [-g <group>] [-r <remote>] repo ls [--archive]               # API list all remote repository'
	echo 'mygit [-g <group>] [-r <remote>] repo del                          # API delete remote repository'
	echo 'mygit [-g <group>] [-r <remote>] repo new [--pri|--pub]            # API create remote repository'
	echo 'mygit [-g <group>] [-r <remote>] repo vis/visibility [--pri|--pub] # API change remote repository visibility'
	echo 'mygit [-g <group>] [-r <remote>] repo desc "<description>"         # API change remote repository description'
	echo 'mygit [-g <group>] [-r <remote>] repo topic "<topics...>"          # API change remote repository topic'
}

option() {
	local _me="option"
	local _action=''
	local _state=0

	while [[ ${ARGV[${ARGP}]} ]]; do
		[[ ${_DEBUG} ]] && LOG "${_me}:ARGP:${ARGP}"
		local _ARG=${ARGV[${ARGP}]}
		((ARGP++))
		case ${_state} in
		0)
			case ${_ARG} in
			"-g" | "--group")
				_state=1
				;;
			"-r" | "--remote")
				_state=2
				;;
			"fetch")
				_action='fetch'
				RUN_CMD "c_fetch"
				;;
			"group")
				_action='group'
				echo ${MY_GIT_GROUP}
				;;
			"init")
				_action='init'
				RUN_CMD "c_init"
				;;
			"push")
				_action='push'
				RUN_CMD "o_push"
				;;
			"repo" | "repository")
				_action='repo'
				RUN_CMD "o_repo"
				;;
			"remote")
				_action='remote'
				for _r in ${MY_GIT_REMOTE}; do
					echo "${_r} (${MY_GIT[${_r}.grp]})"
				done
				;;
			*)
				_action='usage'
				_mygit_usage
				return 1
				;;
			esac
			;;
		1)
			# group
			[[ ${_DEBUG} ]] && LOG "${_me}:-g"
			! _in_group ${_ARG} "${MY_GIT_GROUP}" && echo "Group ${_ARG} not found." && exit 1
			_state=0
			ADD_GROUP ${_ARG}
			[[ ${_DEBUG} ]] && LOG "${_me}:REMOTE:${REMOTE}"
			;;
		2)
			# remote
			[[ ${_DEBUG} ]] && LOG "${_me}:-r"
			! _in_group ${_ARG} "${MY_GIT_REMOTE}" && echo "Remote ${_ARG} not found." && exit 1
			_state=0
			ADD_REMOTE ${_ARG}
			[[ ${_DEBUG} ]] && LOG "${_me}:REMOTE:${REMOTE}"
			;;
		esac
	done

	[[ ! ${_action} ]] && _mygit_usage

}

c_fetch() {
	local _me="c_fetch"
	[[ ${_DEBUG} ]] && LOG "${_me}:ARGP:${ARGP}"

	for _r in $(MERGE_REMOTE); do
		echo remote:${_r}
		RUN_CMD "git fetch $_r"
		echo ---
	done
}

c_init() {

	local _me="o_init"
	[[ ${_DEBUG} ]] && LOG "${_me}:ARGP:${ARGP}"
	[[ ${_DEBUG} ]] && LOG "${_me}:REMOTE:${REMOTE}"

	if [[ ${ARGV[${ARGP}]} ]]; then
		REPO=${ARGV[${ARGP}]}
		# Create .mygit
		echo ${REPO} >.mygit
		((ARGP++))
	else
		REPO=${PWD##*/}
		[ -f ".mygit" ] && rm .mygit
	fi

	git init

	# Clear remote
	_mygit_remote_clear

	[[ ! ${REMOTE} ]] && REMOTE=${MY_GIT_REMOTE}

	for _r in ${REMOTE}; do
		echo remote:${_r}
		_mygit_remote_add ${_r}
	done
}

o_push() {
	local _me="o_push"
	[[ ${_DEBUG} ]] && LOG "${_me}:ARGP:${ARGP}"

	local _OPT=''
	local _BRANCH=''

	local _ARG=${ARGV[${ARGP}]}
	((ARGP++))

	case ${_ARG} in
	"") ;;
	"--all")
		_OPT='' # unset upstream
		_BRANCH="--all"
		;;
	"--master")
		_OPT="-u" # set upstream
		_BRANCH="master"
		;;
	*)
		echo 'usage: mygit <-g <group>|-r <remote>> push <--master|--all>'
		;;
	esac

	for _r in $(MERGE_REMOTE); do
		echo remote:${_r}
		RUN_CMD "git push ${_OPT} ${_r} ${_BRANCH}"
		RUN_CMD "git push ${_r} --tags"
		echo ---
	done

}

o_repo() {
	local _me="o_repo"
	[[ ${_DEBUG} ]] && LOG "${_me}:ARGP:${ARGP}"

	local _state=0
	local _action
	local _archive
	local _desc=''
	local _topic=''
	local _private=''
	local _remote=''
	local _X=' ' # curl -X
	local _D=' ' # curl -d
	local _JQ="."

	while [[ ${ARGV[${ARGP}]} ]]; do
		local _ARG=${ARGV[${ARGP}]}
		[[ ${_DEBUG} ]] && LOG "${_me}:ARG[${ARGP}]:${_ARG}"
		((ARGP++))
		case ${_state} in
		0)
			case ${_ARG} in
			"del" | "delete")
				_action="del"
				;;
			"desc" | "description")
				_action="desc"
				_state=1
				;;
			"ls" | "list")
				_action="ls"
				;;
			"new")
				_action="new"
				;;
			"topic" | "topics")
				_action="topic"
				_state=2
				;;
			"vis" | "visibility")
				_action="vis"
				;;
			"--pri" | "--private")
				_private=true
				;;
			"--pub" | "--public")
				_private=false
				;;
			"--archive" | "--archived")
				_archive=true
				;;
			*)
				echo usage: ${_me}
				return 1
				;;
			esac
			;;
		1)
			[[ ${_DEBUG} ]] && LOG "${_me}:1:_ARG:${_ARG}"
			_state=0
			_desc="${_ARG}"
			;;
		2)
			[[ ${_DEBUG} ]] && LOG "${_me}:2:_ARG:${_ARG}"
			_state=0
			for _t in ${_ARG}; do
				if [ ${_topic} ]; then
					_topic+=",\"${_t}\""
				else
					_topic="\"${_t}\""
				fi
			done
			;;

		esac
	done

	case ${_action} in
	"ls")
		if [[ ${REMOTE} ]]; then
			# list only rely on MY_GIT config
			_remote=${REMOTE}
		else
			# if no group/remote specified, then list all
			_remote=${MY_GIT_REMOTE}
		fi
		;;
	"del")
		if [[ ${REMOTE} ]]; then
			# list only rely on MY_GIT config
			_remote=${REMOTE}
		else
			# if no group/remote specified, then use local remote (git remote -v)
			_remote=$(MERGE_REMOTE)
		fi
		;;
	*)
		_remote=$(MERGE_REMOTE)
		;;
	esac

	[[ ${_DEBUG} ]] && LOG "${_me}:_remote:${_remote}"
	for _r in ${_remote}; do
		local _DEL=${MY_GIT[${_r}.del]}
		local _PRI=${MY_GIT[${_r}.pri]}
		local _TOK=${MY_GIT[${_r}.tok]}
		local _URI=${MY_GIT[${_r}.uri]}
		local _USR=${MY_GIT[${_r}.usr]}
		local _VEN=${MY_GIT[${_r}.ven]}
		local _API

		[[ ${_DEBUG} ]] && LOG "${_me}:_action:${_action}"
		case ${_action} in
		"del")
			_API=${_URI}/repos/${_USR}/${REPO}
			_X="DELETE"
			[[ ${_DEL} ]] && _TOK=${_DEL}
			;;
		"desc")
			_API=${_URI}/repos/${_USR}/${REPO}
			_JQ="-r .description"
			if [[ ${_desc} ]]; then
				_D="{\"description\":\"${_desc}\"}"
				_X="PATCH"
			fi
			;;
		"ls")
			_API=${_URI}/user/repos
			if [ "${_VEN}" = "github" ]; then
				_API="${_API}?per_page=100"
			else # gogs/gitea
				_API="${_API}?limit=100"
			fi

			if [[ ${_archive} ]]; then
				_JQ='-r .[]|{name}|.name'
			else
				_JQ='-r .[]|select(.archived==false)|{name}|.name'
			fi
			;;
		"new")
			if [[ ! ${_private} ]]; then
				if [[ ${_PRI} ]]; then
					_private=${_PRI}
				else
					_private=true
				fi
			fi
			[[ ${_DEBUG} ]] && [[ ${_X} ]] && LOG "${_me}:_private:${_private}"
			_API=${_URI}/user/repos
			_D="{\"name\":\"${REPO}\",\"private\":${_private}}"
			;;
		"topic")
			_API=${_URI}/repos/${_USR}/${REPO}/topics
			if [[ ${_topic} ]]; then
				_X="PUT"
				case ${_VEN} in
				"github")
					_D="{\"names\":[${_topic}]}"
					;;
				"gogs" | "gitea")
					_D="{\"topics\":[${_topic}]}"
					;;
				esac
			fi
			;;
		"vis")
			[[ ${_DEBUG} ]] && [[ ${_X} ]] && LOG "${_me}:_private:${_private}"
			_API=${_URI}/repos/${_USR}/${REPO}
			_JQ='({private})|to_entries[]|"\(.key)=\(.value)"'
			if [[ ${_private} ]]; then
				_D="{\"private\":${_private}}"
				_X="PATCH"
			fi
			;;
		*)
			Get repo remote info
			_API=${_URI}/repos/${_USR}/${REPO}
			_JQ='.'
			;;
		esac

		echo ${_r}:${_API}
		[[ ${_DEBUG} ]] && [[ ${_X} ]] && LOG "${_me}:_X:${_X}"
		[[ ${_DEBUG} ]] && [[ ${_D} ]] && LOG "${_me}:_D:${_D}"
		API_CURL "${_API}" "${_TOK}" "${_X}" "${_D}" "${_JQ}"
		echo ---
	done
}

# ---

# Minimum bash version 4
[[ ${BASH_VERSION} ]] && [[ ${BASH_VERSION} < 4 ]] && echo "${BASH_VERSION} < 4" && exit 1

# CONF
typeset -A MY_GIT
CONF=~/.mygit.conf
if [ -f ${CONF} ]; then
	source ${CONF}
else
	echo "${CONF} not found."
	exit 1
fi
MY_GIT_REMOTE=''
MY_GIT_GROUP=''
_mygit_remote
_mygit_group

# ARG
ARGP=1
ARGC=${#@}
declare -a ARGV
_c=1
for _j in "${@}"; do
	ARGV[${_c}]=${_j}
	((_c++))
done

if [ -f ".mygit" ]; then
	REPO=$(cat .mygit)
else
	REPO=${PWD##*/}
fi
REMOTE=''

# DEBUG
if [[ ${_DEBUG} ]]; then
	LOG BASH_VERSION:${BASH_VERSION}
	LOG MY_GIT_REMOTE:${MY_GIT_REMOTE}
	LOG MY_GIT_GROUP:${MY_GIT_GROUP}
	for _i in $(seq 1 ${#ARGV[@]}); do
		LOG ARGV[${_i}]:${ARGV[${_i}]}
	done
	LOG REPO:${REPO}
fi

option
